{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://stfb/webpack/bootstrap","webpack://stfb/webpack/runtime/define property getters","webpack://stfb/webpack/runtime/hasOwnProperty shorthand","webpack://stfb/webpack/runtime/make namespace object","webpack://stfb/external var \"BABYLON\"","webpack://stfb/./src/core.ts","webpack://stfb/./src/stdlib.ts","webpack://stfb/./src/stfb.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = BABYLON;","/**\n * @packageDocumentation Super Tiny Foundation for BABYLON, enables ECS principle on BABYLON scenes\n * @author Quang-Linh LE\n *\n * System: Global state\n * Components: Functions that take `entity' as its first argument,\n *   enhances, modifies its behavior in some ways\n * Entity: Node, Mesh, Feature etc..\n */\n\nimport * as BABYLON from 'babylonjs';\n\n/**\n * Bootstrap a new system with a `registry'\n *\n * @param registry global state\n * @returns [setElForId, findElById]\n */\nexport function System(registry) {\n  return {\n    setElForId(el, id) {\n      if (registry[id] && registry[id] !== el) {\n        throw new Error(\n          `Id \\`${id}' is already reserved for \\'${registry[id]}'`\n        );\n      } else if (el === undefined) {\n        delete registry[id];\n      } else {\n        registry[id] = el;\n      }\n    },\n    findElById(id) {\n      return registry[id];\n    },\n  };\n}\n\n/**\n * Bootstrap a scene\n * @param sceneOrCanvas \n * @param param1 \n * @returns \n */\nexport async function Scene<T extends BABYLON.Node>(\n  sceneOrCanvas: BABYLON.Scene | HTMLCanvasElement | null,\n  {\n    components,\n    children,\n  }: {\n    components?: (\n      | ((scene: BABYLON.Scene) => void | Promise<void>)\n      | ((scene: BABYLON.Scene, ...args) => void | Promise<void>)\n      | [Function, ...any]\n    )[];\n    children?: ((scene: BABYLON.Scene) => Promise<T>)[];\n  }\n): Promise<BABYLON.Scene> {\n  let canvas: HTMLCanvasElement;\n  let engine: BABYLON.Engine;\n  let scene: BABYLON.Scene;\n\n  // Do we need a default scene?\n\n  if (sceneOrCanvas instanceof BABYLON.Scene) {\n    scene = sceneOrCanvas;\n    engine = scene.getEngine();\n    canvas = engine.getRenderingCanvas();\n  } else {\n    canvas =\n      sceneOrCanvas instanceof HTMLCanvasElement\n        ? sceneOrCanvas\n        : document.createElement(\"canvas\");\n    canvas.style.cssText = \"width: 100%; height: 100%; touch-action: none;\";\n    document.body.appendChild(canvas);\n\n    engine = new BABYLON.Engine(canvas, true, {\n      preserveDrawingBuffer: true,\n      stencil: true,\n      disableWebGL2Support: false,\n    });\n\n    scene = new BABYLON.Scene(engine);\n  }\n\n  for (const component of components || []) {\n    if (Array.isArray(component)) {\n      const [fn, ...args] = component;\n      fn(scene, ...args);\n    } else {\n      await component(scene);\n    }\n  }\n\n  const childEls = await Promise.all(\n    (children || []).map((childFn) => childFn(scene))\n  );\n\n  // Do we need a default light?\n  let light = childEls.find(\n    (el) => el instanceof BABYLON.Light\n  ) as BABYLON.Light;\n  if (!light) {\n    light = CreateDefaultLight(scene);\n  }\n\n  // Do we need a default camera?\n  let camera = childEls.find(\n    (el) => el instanceof BABYLON.Camera\n  ) as BABYLON.Camera;\n  if (!camera) {\n    camera = CreateDefaultCamera(scene);\n  }\n\n  engine.runRenderLoop(() => scene.render());\n\n  return scene;\n}\n\n/**\n * Entity is basically a Mesh or a Feature that its behavior can be modified by some functions (Components)\n * and may have children that are also Entities\n * @param fn \n * @param param1 \n * @returns \n */\nexport function Entity<T>(\n  fn: (scene: BABYLON.Scene) => T | Promise<T>,\n  {\n    components,\n    children,\n  }: {\n    components?: (\n      | ((el: T) => void | Promise<void>)\n      | ((el: T, ...args) => void | Promise<void>)\n      | [(el: T, ...args) => void | Promise<void>, ...any]\n    )[];\n    children?: ((scene: BABYLON.Scene) => Promise<T & { parent: any }>)[]; // super of T?\n  } = { components: [], children: [] }\n) {\n  return async (scene: BABYLON.Scene) => {\n    const el = await fn(scene);\n\n    for (const component of components || []) {\n      if (Array.isArray(component)) {\n        const [fn, ...args] = component;\n        fn(el, ...args);\n      } else {\n        await component(el);\n      }\n    }\n\n    for (const childFn of children || []) {\n      let childEl = await childFn(scene);\n      if (Array.isArray(childEl)) {\n        for (const c of childEl) {\n          c.parent = el;\n        }\n      } else {\n        childEl.parent = el;\n      }\n    }\n\n    return el;\n  };\n}\n\n/**\n * Create a default Light for `scene` (if not exist)\n *\n * A `Component` for `scene`\n * @param scene\n * @returns\n */\nexport function CreateDefaultLight(scene: BABYLON.Scene) {\n  // This creates a light, aiming 0,1,0 - to the sky (non-mesh)\n  const light = new BABYLON.HemisphericLight(\n    \"light\",\n    new BABYLON.Vector3(0, 1, 0),\n    scene\n  );\n\n  // Default intensity is 1. Let's dim the light a small amount\n  light.intensity = 0.7;\n  return light;\n}\n\n/**\n * Create a default Camera for `scene` (if not exist)\n *\n * A `Component` for `scene`\n * @param scene\n * @returns\n */\nexport function CreateDefaultCamera(scene: BABYLON.Scene) {\n  // This creates and positions a free camera (non-mesh)\n  const camera = new BABYLON.FreeCamera(\n    \"camera\",\n    new BABYLON.Vector3(0, 5, -10),\n    scene\n  );\n\n  // This targets the camera to scene origin\n  camera.setTarget(BABYLON.Vector3.Zero());\n\n  // This attaches the camera to the canvas\n  camera.attachControl(scene.getEngine().getRenderingCanvas(), true);\n  return camera;\n}\n","/**\n * @packageDocumentation Super Tiny Foundation, stdlib\n * @author Quang-Linh LE\n */\n\n// Physics\n\nimport * as BABYLON from 'babylonjs';\nimport Ammo from 'ammojs-typed'\n\n/**\n * Compnent: Enable physics for `scene'\n * @param scene\n */\nexport async function enablePhysics(scene: BABYLON.Scene) {\n  scene.enablePhysics(\n    new BABYLON.Vector3(0, -9.81, 0),\n    new BABYLON.AmmoJSPlugin()\n  );\n}\n\n/**\n * Component: With physics enabled on scene, enable it for mesh `el'\n * @param el\n * @param mass\n * @param restitution\n */\nexport function withPhysics(\n  el: BABYLON.Mesh,\n  mass: number,\n  restitution: number\n) {\n  const physicsImpostor = new BABYLON.PhysicsImpostor(\n    el,\n    BABYLON.PhysicsImpostor.SphereImpostor,\n    { mass, restitution },\n    el.getScene()\n  );\n  el.physicsImpostor = physicsImpostor;\n}\n\n// Debug\n\n/**\n * Component: Enable debug for scene\n * @param scene\n */\nexport async function enableDebug(scene: BABYLON.Scene) {\n  scene.debugLayer.show();\n}\n\n// Material\n\nexport function withPBRMatByColor(el: BABYLON.Mesh, color: string) {\n  const mat = new BABYLON.PBRMaterial(\"blue\", el.getScene());\n  mat.albedoColor = BABYLON.Color3.FromHexString(color);\n  mat.metallic = 0.99;\n  mat.roughness = 0.01;\n  el.material = mat;\n}\n\nexport function withRedMat(el: BABYLON.Mesh) {\n  return withPBRMatByColor(el, \"#EF2D5E\");\n}\n\nexport function withGreenMat(el: BABYLON.Mesh) {\n  return withPBRMatByColor(el, \"#7BC8A4\");\n}\n\nexport function withBlueMat(el: BABYLON.Mesh) {\n  return withPBRMatByColor(el, \"#4CC3D9\");\n}\n\nexport function withYellowMat(el: BABYLON.Mesh) {\n  return withPBRMatByColor(el, \"#FFC65D\");\n}\n\n// XR\n\n/**\n * Entity: Add XR on `scene'\n * @param scene\n */\nexport async function XR(scene) {\n  return scene.createDefaultXRExperienceAsync();\n}\n\n/**\n * Enable Pointer Selection\n *\n * A Component for `xrHelper`\n * @param xrHelper\n */\nexport async function withPointerSelection(\n  xrHelper: BABYLON.WebXRDefaultExperience\n) {\n  const featuresManager = xrHelper.baseExperience.featuresManager;\n\n  featuresManager.enableFeature(\n    BABYLON.WebXRFeatureName.POINTER_SELECTION,\n    \"stable\",\n    {\n      xrInput: xrHelper.input,\n      enablePointerSelectionOnAllControllers: true,\n    }\n  );\n}\n\n/**\n * Enable Teleportation\n *\n * A Component for `xrHelper`\n * @param xrHelper\n * @param floors\n */\nexport async function withTeleportation(\n  xrHelper: BABYLON.WebXRDefaultExperience,\n  floors: BABYLON.Mesh[] | Function | undefined\n) {\n  const featuresManager = xrHelper.baseExperience.featuresManager;\n\n  let floorMeshes: BABYLON.Mesh[];\n\n  if (floors instanceof Function) {\n    floorMeshes = floors();\n  } else {\n    if (!floors || floors.length === 0) {\n      const scene = xrHelper.baseExperience.sessionManager.scene;\n      const ground = BABYLON.MeshBuilder.CreateGround(\n        \"ground\",\n        {\n          width: 400,\n          height: 400,\n        },\n        scene\n      );\n      floors = [ground];\n    }\n    floorMeshes = floors;\n  }\n\n  featuresManager.enableFeature(\n    BABYLON.WebXRFeatureName.TELEPORTATION,\n    \"stable\",\n    {\n      xrInput: xrHelper.input,\n      floorMeshes: floorMeshes,\n      snapPositions: [],\n    }\n  );\n}\n\n/**\n * Enable handtracking\n *\n * A Component for `xrHelper`\n * @param xrHelper\n * @param setElForId\n * @param leftHandId\n * @param rightHandId\n */\nexport async function withHandTracking(\n  xrHelper: BABYLON.WebXRDefaultExperience,\n  setElForId: Function,\n  leftHandId = \"leftHand\",\n  rightHandId = \"rightHand\"\n) {\n  const featuresManager = xrHelper.baseExperience.featuresManager;\n\n  const availableFeatures = BABYLON.WebXRFeaturesManager.GetAvailableFeatures();\n\n  if (\n    availableFeatures.find(\n      (it) => it === BABYLON.WebXRFeatureName.HAND_TRACKING\n    )\n  ) {\n    const xrHandFeature: BABYLON.IWebXRFeature & any =\n      featuresManager.enableFeature(\n        BABYLON.WebXRFeatureName.HAND_TRACKING,\n        \"latest\",\n        {\n          xrInput: xrHelper.input,\n        }\n      );\n\n    xrHandFeature.onHandAddedObservable.add((hand) => {\n      console.log(\"HAND ADDED\", hand);\n\n      if (hand.xrController.inputSource.handedness === \"left\") {\n        setElForId(hand, leftHandId);\n      }\n      if (hand.xrController.inputSource.handedness === \"right\") {\n        setElForId(hand, rightHandId);\n      }\n    });\n\n    xrHandFeature.onHandRemovedObservable.add((hand) => {\n      console.log(\"HAND REMOVED\", hand);\n\n      if (hand.xrController.inputSource.handedness === \"left\") {\n        setElForId(undefined, leftHandId);\n      }\n      if (hand.xrController.inputSource.handedness === \"right\") {\n        setElForId(undefined, rightHandId);\n      }\n    });\n  }\n}\n\n// Pick\n\n/**\n * Component: Action when the mesh has been pick (but not neccessary release)\n * @param el\n * @param setElForId\n * @param cb\n */\nexport async function onPickedDown(\n  el: BABYLON.Mesh,\n  setElForId: Function,\n  cb: Function\n) {\n  const scene = el.getScene();\n\n  // FIXME(QL): How to cleanup?\n  const observer = scene.onPointerObservable.add((pointerInfo) => {\n    switch (pointerInfo.type) {\n      case BABYLON.PointerEventTypes.POINTERDOWN:\n        if (pointerInfo.pickInfo.hit) {\n          let pickedMesh = pointerInfo.pickInfo.pickedMesh;\n          let pointerId = (pointerInfo.event as any).pointerId;\n          if (pickedMesh === el) {\n            setElForId(pointerId, observer);\n            cb(pointerInfo);\n          }\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Component: Action when mesh has been release, should work only when `onPickedDown` is also set\n * @param el\n * @param findElById\n * @param cb\n */\nexport async function onPickedUp(\n  el: BABYLON.Mesh,\n  findElById: Function,\n  cb: Function\n) {\n  const scene = el.getScene();\n\n  // FIXME(QL): How to cleanup?\n  const observer = scene.onPointerObservable.add((pointerInfo) => {\n    switch (pointerInfo.type) {\n      case BABYLON.PointerEventTypes.POINTERUP:\n        let pointerId = (pointerInfo.event as any).pointerId;\n        if (findElById(pointerId)) {\n          cb(pointerId);\n        }\n        break;\n    }\n  });\n}\n","declare global {\n  /**\n   * Window with STFB\n   */\n  interface Window {\n    STFB: {\n      // how to declare all the export here\n    } & ((into?: any) => void);\n  }\n}\n\nimport * as core from \"./core\";\nimport * as stdlib from \"./stdlib\";\n\n((window: Window) => {\n  const savedSTFB = window.STFB;\n\n  window.STFB = ((into?: any) => {\n    into = into || window;\n    Object.assign(into, core);\n    Object.assign(into, stdlib);\n\n    if (savedSTFB) {\n      window.STFB = savedSTFB;\n    }\n  }) as any;\n\n  Object.assign(window.STFB, core);\n  Object.assign(window.STFB, stdlib);\n})(window);\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","BABYLON","System","registry","setElForId","el","id","Error","undefined","findElById","async","Scene","sceneOrCanvas","components","children","canvas","engine","scene","getEngine","getRenderingCanvas","HTMLCanvasElement","document","createElement","style","cssText","body","appendChild","preserveDrawingBuffer","stencil","disableWebGL2Support","component","Array","isArray","fn","args","childEls","Promise","all","map","childFn","light","find","CreateDefaultLight","camera","CreateDefaultCamera","runRenderLoop","render","Entity","childEl","c","parent","intensity","setTarget","attachControl","enablePhysics","withPhysics","mass","restitution","physicsImpostor","getScene","enableDebug","debugLayer","show","withPBRMatByColor","color","mat","albedoColor","metallic","roughness","material","withRedMat","withGreenMat","withBlueMat","withYellowMat","XR","createDefaultXRExperienceAsync","withPointerSelection","xrHelper","baseExperience","featuresManager","enableFeature","xrInput","input","enablePointerSelectionOnAllControllers","withTeleportation","floors","floorMeshes","Function","length","sessionManager","width","height","snapPositions","withHandTracking","leftHandId","rightHandId","it","xrHandFeature","onHandAddedObservable","add","hand","console","log","xrController","inputSource","handedness","onHandRemovedObservable","onPickedDown","cb","observer","onPointerObservable","pointerInfo","type","pickInfo","hit","pickedMesh","pointerId","event","onPickedUp","window","savedSTFB","STFB","into","assign"],"sourceRoot":""}